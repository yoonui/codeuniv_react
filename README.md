# 1일차 : 리액트란?

리액트란? 2013년, 페이스북에서 개발한 자바스크립트 라이브러리로, 사용하는 웹의 UI를 쉽게 만들어준다.


- 리액트의 장점 "컴포넌트" : 함수를 만들어 코드의 가독성과 유지보수를 쉽게 할 수 있는 것처럼, UI요소들을 컴포넌트로 선언해 코드의 절대량을 줄이고, 가독성을 높일 수 있다. 즉, 컴포넌트를 기반으로 재사용성이 높다.

- 사전 준비 : 사용할 리액트의 초기 설정에서는 Webpack, Babel과 같은 도구들을 사용하게 된다. 이러한 도구들은 Nodejs를 기반으로 작성되어 있으므로, Node를 설치한다. 또한, 개발을 위해 사용할 에디터를 준비한다.



# 2일차 : 프로젝트 생성과 Hello, React!
터미널에 아래 명령어 입력

$ npx craete-react-app mogakko-react

create-react-app은 페이스북에서 만든 bolilerplate로, 리액트 개발을 시작할 수 있도록 만들어둔 기초 골격이라고 볼 수 있다.


- App.js 파일에서는 HTML 태그를 리턴하는 App 함수를 선언하고 있다. 이렇게 HTML 형식의 값을 반환해주거나 변수에 HTML을 대입할 수 있는 문법을 JavaScript eXtension, 줄여서 'JSX'라고 한다.

- export 키워드를 통해 함수를 내보낼 수 있다. 이렇게 내보내진 함수를 컴포넌트라고 부른다. 다른 컴포넌트에서 이를 불러와 사용할 수 있게 되는 것이다. 따라서 웹 페이지를 만들 때, 헤더나 목차 등을 컴포넌트로 생성한다면 필요할 때 불러오기만 하면 되므로, 재사용성이 높은 것이다.



# 3일차 : 컴포넌트 스타일링
HTML에서와 마찬가지로, CSS 파일을 만들고 컴포넌트에서 불러와 사용할 수 있다. 예제에서 Hello.js는 Hello.css를 불러오고, Bye.js는 css 파일을 불러오지 않는 채로 두 js 모두 같은 클래스 이름을 사용한다. 이 경우, Bye.js는 css를 불러오지 않았음에도 불구하고 Hello.css가 적용된 것을 확인할 수 있다.

이는 컴포넌트 단위로 나뉜 수많은 파일들을 하나로 합친 파일로 요청하는것이 자원도 덜 들고 속도도 빠르기 때문에, 리액트의 모든 파일은 하나의 파일로 합쳐지게 된다. 이렇게 리액트의 모든 파일을 하나로 압축하는 과정에서 Hello 컴포넌트와 Bye 컴포넌트의 클래스 이름은 똑같다고 처리하기 때문에, Bye 컴포넌트에서 css를 불러오지 않더라도 Hello 컴포넌트에서 불러온 css 속성이 적용된 것이다.

이러한 문제를 해결하기 위해 나온 것이 CSS Module 이라는 것이다. 이를 사용하게 되면 각 컴포넌트마다 고유한 클래스 이름을 가질 수 있다.

CSS만을 사용했을 땐 다른 컴포넌트에서 작성한 클래스 이름도 똑같이 출력되었지만, CSS Module을 사용하니 추가적으로 컴포넌트 이름과 해쉬값이 붙어, 고유한 클래스 이름이 된다.



# 4일차 : Hook와 State
리액트에서 제공하는 기본적인 기능은 Hook라는 이름으로 제공된다. Hook는 대표적으로 상태관리를 위한 useState, 렌더링 전후의 작업을 담당하는 useEffect 등이 존재하며, 4일차에서는 상태관리에 사용되는 useState를 알아본다.

- 리액트의 컴포넌트들은 여러가지 데이터를 받아야 하는 경우가 많다. 이 데이터는 컴포넌트 내부에서 선언할수도, 다른 컴포넌트로부터 넘겨받을수도 있다. 내부에서 선언되고 관리되는 데이터를 State라고 하며, 컴포넌트로부터 받은 데이터를 Props라고 한다. 즉, Props는 함수에 전달되는 매개변수, State는 함수에서 선언된 변수 값이라고 이해하면 된다.

$ const [상태 변수, 상태 값 변경 함수] = useState(초기값);

- var를 놔두고 useState를 사용하는 이유는 변수가 변해도 렌더링이 다시 되지 않기 때문이다. 렌더링이란, 사용자 화면에 내용을 보여주는 것을 의미한다. 변수가 변해도 렌더링이 다시 되지 않는다면, 데이터의 변화를 사용자가 볼 수 있다는 의미이다. 즉, 단순히 var로 변수를 선언하게 되면 변수 값 자체는 증가하지만, 상태는 변경되지 않아 리렌더링이 일어나지 않는다.



# 5일차 : Props
리액트에서 데이터는 위에서 아래로, 즉 부모 컴포넌트에서 자식 컴포넌트로 진행되는 단방향의 흐름을 가진다. 이 데이터의 흐름 아래에서 자식에게 전달되는 데이터가 Props인 것이다.

- 비구조화 할당 : 객체의 구조를 해체하고 변수에 대입하는 것이다. 이렇게 비구조화 할당을 사용하는 경우, 코드의 가독성이 올라갈 뿐만 아니라, 다른 사람이 컴포넌트의 구조를 볼 때 각 컴포넌트마다 필요한 데이터의 종류를 손쉽게 파악할 수 있다.

- 컴포넌트 안에 다른 태그나 컴포넌트를 담을 수 있다. 이는 children을 사용하면 된다.



# 6일차 : 데이터 준비
- JSON : JavaScript Object Notation의 줄임말로, 쉽게 말해 키-값 쌍으로 이루어진 객체 형태의 데이터이다. 보통 서버에 데이터를 요청하고, 서버가 데이터를 보내줄 때 JSON을 사용한다.

$ import youtubeData from './data/youtubeData.json';

CSS나 컴포넌트를 불러왔던 것과 마찬가지로, JSON 역시 import 구문을 사용한다. 이렇게 json에서 받아온 데이터는 리액트에서 객체로 동작한다.



# 7일차 : 레이아웃 구성
리액트의 컴포넌트는 장점만 있는 것은 아니다. 혼자하는 프로젝트라면 규모도 작고 자신의 코드이기 때문에 그나마 파악이 가능하지만, 협업을 하는 대형 프로젝트라면 파악이 어려워진다. 따라서 각 컴포넌트의 역할에 맞게 폴더 구조를 분리해야 한다.

유튜브 사이트에서 홈, 탐색, 구독 세 페이지 모드 상단 고정바와 목차가 사용된다. 따라서 한 페이지를 크게 상단 고정바, 목차, 컨텐츠 3가지로 분리할 수 있다.
- Header 컴포넌트 : 상단 고정바
- Menu 컴포넌트 : 목차

헤더, 목차, 컨텐츠의 형태가 모두 같기 때문에, 각 페이지에서 사용할 수 있는 페이지의 틀을 구성한다.



# 8일차 : 아이콘과 헤더
아이콘은 직접 파일로 추가해줄수도 있지만, 라이브러리를 설치해서 받아올수도 있다.

$ npm install react-icons

라이브러리를 사용하는 방법은 공식 홈페이지를 참고한다.

https://react-icons.github.io/react-icons/icons?name=bi

이미지의 경로 또한 아래와 같이 import를 사용해 받아와야 한다.

$ import youtube_logo from '../../data/youtube_logo.png';



# 9일차 : SPA와 링크
HTML을 다룰 땐 단순히 a 태그를 사용하면 링크를 만들 수 있었다. 그러나 리액트는 이러한 페이지 이동이 불가능하다. 이는 리액트의 또 다른 특성인 Single Page Application(SPA) 때문이다. 말 그대로, 리액트는 페이지가 하나인 어플리케이션이므로 페이지 이동이 불가능하다.

SPA에서는 페이지 이동이 아닌, '주소값에 따른 화면'을 만들어준다. 이렇게 주소마다 다른 화면을 보여주는 것을 라우팅(routing)이라고 한다.

라우팅을 가능하게 해주는 라이브러리를 설치한다.

$ npm install react-router-dom

설치를 마친 뒤, 리액트 앱에서 라우팅이 가능하도록 설정해준다. src 폴더의 index.js 파일에서 App 컴포넌트를 BrowserRouter로 감싸준다. 여기서 index.js는 리액트의 최상단에 위치한 컴포넌트이다. 렌더링되는 유일한 컴포넌트인 App 컴포넌트를 BrowserRouter로 감싸줌으로서, 리액트 앱에서 라우팅을 가능하도록 허락한 것이다.



# 10일차 : 메뉴 구현
실제 유튜브 페이지는 현재 열린 메뉴가 진한 회색으로 표시되고 있다. 이러한 스타일링은 컴포넌트간의 데이터 전달과 삼항연산자로 구현할 수 있다.

- 현재 활성화된 메뉴 정보는 페이지 컴포넌트에서 얻을 수 있고, 이 데이터는 Menu 컴포넌트에서 필요하다. 페이지에서 직접적으로 Menu 컴포넌트를 사용하지 않기 때문에, 중간에 Layout 컴포넌트를 거쳐서 보내야 한다. 즉, 페이지에서 Layout으로, Layout에서 Menu로 현재 활성화된 메뉴 정보를 보낸 뒤에, Menu에서 현재 활성화된 메뉴에 추가적인 스타일링을 한다.



# 11일차 : 미디어 쿼리
페이지 소스에서 영상의 width를 담당하는 컴포넌트가 페이지의 크기에 따라 달라진다. 이렇게 화면의 크기에 따라 스타일이 변경되는 웹 페이지를 '반응형 웹'이라고 한다. 구현하는 방법에는 여러가지가 있지만, 여기서는 '미디어 쿼리'를 사용한다.
- 미디어 쿼리란 구체적인 조건으로 스타일을 적용할 수 있도록 확장된 문법이다. 기존의 클래스나 id, 태그에만 적용하던 스타일 방식에서 벗어나, 조건문과 유사하게 스타일링이 가능하다.

메뉴의 너비가 넓은 탓에, 화면이 작을 때 영상을 표현할 공간이 부족한 것을 방지하기 위해 실제 유튜브 페이지처럼 너비가 작아지면 아이콘만 남기도록 한다. 페이지가 줄어듬에 따라 아이콘을 남기기 위해선, 네가지 작업이 필요하다.
- 메뉴 컴포넌트의 문자열을 태그로 묶기 : 너비가 줄어들었을 때, 아이콘만 남기기 위해선 홈, 탐색, 구독 문자를 지워야 한다. 그러나 문자열이 따로 묶여있지 않아, 이 상태로는 글을 지울 수 없다. 따라서 DIV 태그로 묶어준 뒤, text라는 클래스 이름을 부여한다.
- 메뉴 컴포넌트에 미디어 쿼리 적용
- Layouy 컴포넌트에 미디어 쿼리 적용
- ContentsLayout 컴포넌트 CSS 수정

